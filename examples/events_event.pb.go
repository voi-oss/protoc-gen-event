// Code generated by protoc-gen-event. DO NOT EDIT.

package examples

import (
	context "context"
	watermill "github.com/ThreeDotsLabs/watermill"
	message "github.com/ThreeDotsLabs/watermill/message"
	protojson "google.golang.org/protobuf/encoding/protojson"
)

// Publish will JSON marshal and publish this on a publisher
func (e *NotifyEvent) Publish(ctx context.Context, publisher message.Publisher) error {
	return e.PublishWithUUID(ctx, publisher, watermill.NewUUID())
}

// PublishWithUUID will JSON marshal and publish this on a publisher with the given UUID
func (e *NotifyEvent) PublishWithUUID(ctx context.Context, publisher message.Publisher, uuid string) error {
	payload, err := protojson.Marshal(e)
	if err != nil {
		return err
	}

	msg := message.NewMessage(uuid, payload)
	msg.SetContext(ctx)

	return publisher.Publish("voi.protocgenevent.examples.NotifyEvent", msg)
}

// Simple consumer wrapper
type intNotifyEventHandler struct {
	HandlerFunc func(pe *NotifyEvent, m *message.Message) error
}

func NotifyEventHandler(f func(pe *NotifyEvent, m *message.Message) error) *intNotifyEventHandler {
	return &intNotifyEventHandler{
		HandlerFunc: f,
	}
}

func (h *intNotifyEventHandler) Topic() string {
	return "voi.protocgenevent.examples.NotifyEvent"
}

func (h *intNotifyEventHandler) Handle(m *message.Message) error {
	pe := &NotifyEvent{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	if err := opts.Unmarshal(m.Payload, pe); err != nil {
		return err
	}

	return h.HandlerFunc(pe, m)
}

// Publish will JSON marshal and publish this on a publisher
func (e *CustomTopicEvent) Publish(ctx context.Context, publisher message.Publisher) error {
	return e.PublishWithUUID(ctx, publisher, watermill.NewUUID())
}

// PublishWithUUID will JSON marshal and publish this on a publisher with the given UUID
func (e *CustomTopicEvent) PublishWithUUID(ctx context.Context, publisher message.Publisher, uuid string) error {
	payload, err := protojson.Marshal(e)
	if err != nil {
		return err
	}

	msg := message.NewMessage(uuid, payload)
	msg.SetContext(ctx)

	return publisher.Publish("some-topic", msg)
}

// Simple consumer wrapper
type intCustomTopicEventHandler struct {
	HandlerFunc func(pe *CustomTopicEvent, m *message.Message) error
}

func CustomTopicEventHandler(f func(pe *CustomTopicEvent, m *message.Message) error) *intCustomTopicEventHandler {
	return &intCustomTopicEventHandler{
		HandlerFunc: f,
	}
}

func (h *intCustomTopicEventHandler) Topic() string {
	return "some-topic"
}

func (h *intCustomTopicEventHandler) Handle(m *message.Message) error {
	pe := &CustomTopicEvent{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	if err := opts.Unmarshal(m.Payload, pe); err != nil {
		return err
	}

	return h.HandlerFunc(pe, m)
}

// Publish will JSON marshal and publish this on a publisher
func (e *AttributeEvent) Publish(ctx context.Context, publisher message.Publisher) error {
	return e.PublishWithUUID(ctx, publisher, watermill.NewUUID())
}

// PublishWithUUID will JSON marshal and publish this on a publisher with the given UUID
func (e *AttributeEvent) PublishWithUUID(ctx context.Context, publisher message.Publisher, uuid string) error {
	payload, err := protojson.Marshal(e)
	if err != nil {
		return err
	}

	msg := message.NewMessage(uuid, payload)
	msg.Metadata.Set("AccountID", e.GetAccountID())
	msg.Metadata.Set("zone_id", e.GetZoneID())
	msg.SetContext(ctx)

	return publisher.Publish("voi.protocgenevent.examples.AttributeEvent", msg)
}

// Simple consumer wrapper
type intAttributeEventHandler struct {
	HandlerFunc func(pe *AttributeEvent, m *message.Message) error
}

func AttributeEventHandler(f func(pe *AttributeEvent, m *message.Message) error) *intAttributeEventHandler {
	return &intAttributeEventHandler{
		HandlerFunc: f,
	}
}

func (h *intAttributeEventHandler) Topic() string {
	return "voi.protocgenevent.examples.AttributeEvent"
}

func (h *intAttributeEventHandler) Handle(m *message.Message) error {
	pe := &AttributeEvent{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	if err := opts.Unmarshal(m.Payload, pe); err != nil {
		return err
	}

	return h.HandlerFunc(pe, m)
}
