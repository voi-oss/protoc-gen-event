package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/voi-oss/protoc-gen-event/pkg/options"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPkg   = protogen.GoImportPath("context")
	messagePkg   = protogen.GoImportPath("github.com/ThreeDotsLabs/watermill/message")
	watermillPkg = protogen.GoImportPath("github.com/ThreeDotsLabs/watermill")
	protoJSONPkg = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
)

type requiredField struct {
	Name string
	Type string
}

func (field requiredField) CanonicalRef() string {
	return field.Type + ":" + field.Name
}

type requiredFields []requiredField

func (fields requiredFields) EnsureCompliance(message *protogen.Message) error {
	// Map of required fields we will be looking for
	fieldsMap := make(map[string]requiredField)
	for _, field := range fields {
		fieldsMap[field.CanonicalRef()] = field
	}

	// Check every field in the given message against the map of required fields
	for _, msgField := range message.Fields {
		var fieldType string
		if msgField.Desc.Kind() == protoreflect.MessageKind {
			fieldType = string(msgField.Desc.Message().FullName())
		} else {
			fieldType = msgField.Desc.Kind().String()
		}

		canonicalRef := fieldType + ":" + string(msgField.Desc.Name())

		delete(fieldsMap, canonicalRef)
	}

	// We found all the required fields
	if len(fieldsMap) == 0 {
		return nil
	}

	sourceFilePath := message.Location.SourceFile
	messageName := message.Desc.Name()

	for _, requiredField := range fieldsMap {
		fmt.Fprintf(os.Stderr, "%s: Required field missing in message '%s', expected field '%s' with type '%s'.\n", sourceFilePath, messageName, requiredField.Name, requiredField.Type)
	}

	return fmt.Errorf("some required fields are missing")
}

type GeneratorConfig struct {
	Suffix         string
	RequiredFields requiredFields
}

type messageOptions struct {
	topic             string
	skip              bool
	messageValidation bool
}

type fieldOptions struct {
	isMetadata      bool
	name            string
	injectMessageID bool
}

// generateFile generates a _grpc.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, config GeneratorConfig) (*protogen.GeneratedFile, error) {
	if len(file.Messages) == 0 {
		return nil, nil
	}

	generated := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+"_event.pb.go", file.GoImportPath)
	generated.P("// Code generated by protoc-gen-event. DO NOT EDIT.")
	generated.P()
	generated.P("package ", file.GoPackageName)
	generated.P()

	if err := generateFileContent(file, generated, config); err != nil {
		return nil, err
	}

	return generated, nil
}

// generateFileContent generates events definitions, excluding the package statement.
func generateFileContent(file *protogen.File, g *protogen.GeneratedFile, config GeneratorConfig) error {
	if len(file.Messages) == 0 {
		return nil
	}

	for _, message := range file.Messages {
		if err := generateEvent(g, message, config); err != nil {
			return err
		}
	}

	return nil
}

// generateEvent generates the functions needed to integrate an event with Watermill.
func generateEvent(g *protogen.GeneratedFile, message *protogen.Message, config GeneratorConfig) error {
	opts := getOptions(message, config)
	if opts.skip {
		return nil
	}

	if err := config.RequiredFields.EnsureCompliance(message); err != nil {
		return err
	}

	g.P("// Publish will JSON marshal and publish this on a publisher")
	g.Annotate(message.GoIdent.String()+".Publish", message.Location)
	g.P("func (e *", message.GoIdent, ") Publish(ctx ", g.QualifiedGoIdent(contextPkg.Ident("Context")), ", publisher ", g.QualifiedGoIdent(messagePkg.Ident("Publisher")), ") error {")
	g.P("return e.PublishWithUUID(ctx, publisher, ", watermillPkg.Ident("NewUUID"), "()", ")")
	g.P("}")

	g.P()

	g.P("// injectMessageID will inject the given message UUID into all fields marked with the `inject_message_id` option")
	g.Annotate(message.GoIdent.String()+".injectMessageID", message.Location)
	g.P("func (e *", message.GoIdent, ") injectMessageID(uuid string) {")
	for _, field := range message.Fields {
		fo := getFieldOptions(field)
		if !fo.injectMessageID {
			continue
		}
		g.P("e.", fo.name, " = uuid")
	}
	g.P("}")

	g.P()

	g.P("// PublishWithUUID will JSON marshal and publish this on a publisher with the given UUID")
	g.Annotate(message.GoIdent.String()+".PublishWithUUID", message.Location)
	g.P("func (e *", message.GoIdent, ") PublishWithUUID(ctx ", g.QualifiedGoIdent(contextPkg.Ident("Context")), ", publisher ", g.QualifiedGoIdent(messagePkg.Ident("Publisher")), ", uuid string) error {")

	// messageID injection
	g.P("e.injectMessageID(uuid)")
	g.P()

	// if available: message validation
	if opts.messageValidation {
		g.P("if v, ok := interface{}(e).(interface{ Validate() error }); ok {")
		g.P("if err := v.Validate(); err != nil {")
		g.P("return err")
		g.P("}")
		g.P("}")
		g.P()
	}

	// payload marshalling
	g.P("payload, err := ", g.QualifiedGoIdent(protoJSONPkg.Ident("Marshal")), "(e)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")

	g.P()

	// message publication
	g.P("msg := message.NewMessage(uuid, payload)")

	for _, field := range message.Fields {
		fo := getFieldOptions(field)
		if !fo.isMetadata {
			continue
		}
		g.P("msg.Metadata.Set(\"", fo.name, "\", e.Get", field.GoName, "())")
	}

	g.P("msg.SetContext(ctx)")
	g.P()

	g.P("return publisher.Publish(\"", opts.topic, "\", msg)")
	g.P("}")

	g.P()

	g.P("// Simple consumer wrapper")
	g.P("type int", message.GoIdent, "Handler struct {")
	g.P("HandlerFunc func(pe *", message.GoIdent, ", m *", messagePkg.Ident("Message"), ") error")
	g.P("}")

	g.P("func ", message.GoIdent, "Handler(f func(pe *", message.GoIdent, ", m *", messagePkg.Ident("Message"), ") error) *int", message.GoIdent, "Handler {")
	g.P("return &int", message.GoIdent, "Handler {")
	g.P("HandlerFunc: f,")
	g.P("}")
	g.P("}")

	g.P()
	g.P("func (h *int", message.GoIdent, "Handler) Topic() string { ")
	g.P("return \"", opts.topic, "\"")
	g.P("}")

	g.P()
	g.P("func (h *int", message.GoIdent, "Handler) Handle(m *", messagePkg.Ident("Message"), ") error { ")
	g.P("pe := &", message.GoIdent, "{}")
	g.P("opts := protojson.UnmarshalOptions{")
	g.P("DiscardUnknown: true,")
	g.P("}")
	g.P("if err := opts.Unmarshal(m.Payload, pe); err != nil {")
	g.P("return err")
	g.P("}")
	g.P()
	g.P("return h.HandlerFunc(pe, m)")
	g.P("}")

	return nil
}

func getOptions(message *protogen.Message, config GeneratorConfig) messageOptions {
	mo := messageOptions{
		topic:             string(message.Desc.FullName()),
		skip:              !strings.HasSuffix(string(message.Desc.Name()), config.Suffix),
		messageValidation: true,
	}

	msgOpts := message.Desc.Options().(*descriptorpb.MessageOptions)
	opts := proto.GetExtension(msgOpts, options.E_Options).(*options.EventOption)

	if opts.GetTopicName() != "" {
		mo.topic = opts.GetTopicName()
	}
	if opts.GetSkip() {
		mo.skip = opts.GetSkip()
	}
	mo.messageValidation = !opts.GetNoMessageValidation()

	return mo
}

func getFieldOptions(field *protogen.Field) fieldOptions {
	fo := fieldOptions{
		isMetadata:      false,
		injectMessageID: false,
		name:            field.GoName,
	}

	msgOpts := field.Desc.Options().(*descriptorpb.FieldOptions)
	opts := proto.GetExtension(msgOpts, options.E_Field).(*options.FieldOption)

	if opts.GetIsMetadata() {
		fo.isMetadata = opts.GetIsMetadata()
	}
	if opts.GetInjectMessageId() {
		fo.injectMessageID = opts.GetInjectMessageId()
	}
	if opts.GetName() != "" {
		fo.name = opts.GetName()
	}

	return fo
}
